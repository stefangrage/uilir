---
import MainLayout from "../layouts/MainLayout.astro";
import Button from '../components/Button.astro';
import Link from '../components/Link.astro';
import { Code } from "astro:components";
import { Image } from "astro:assets";
import radio from "../assets/images/radio.jpg"
import kodakelektralitesh from "../assets/images/kodak-elektralite-sh.jpg";
import kodakelektralitefarver from "../assets/images/kodak-elektralite-farver.jpg";
import doubleshot from "../assets/images/doubleshot.jpg";
import dobbeltexp from "../assets/images/dobbeltexp.jpeg";
import baad1 from "../assets/images/baad1.png";
import baad2 from "../assets/images/baad2.png";
import baad3 from "../assets/images/baad3.png";
import lomo from "../assets/images/lomo.jpeg";
---
<MainLayout title="Titel">
	<!-- Intro/Indholdsfortegnelse mm. -->
	<section class="pt-1">
	<h2 class="text-6xl font-extrabold font-black">Intro</h2>
	<p>En masse små kodestumper med interaktioner og animationer klar til at blive copy-pastet og tilpasset.</p>
	<p>Kodestumperne forudsætter at du bruger starteren <Link href="https://github.com/stefangrage/did-e24-starter.git" target="_blank">DiDe starter templaten</Link> med Astro, Tailwind, Alpine, Motion One mm..</p>
	<h3 class="">Indholdsfortegnelse</h3>
	<ul>
		<div class="columns-2 gap-8 pt-4">
			<li><Link href="#rollingbanner" alt="">Rolling/marquee banner</Link></li>
			<li><Link href="#lydeffekter" alt="">Lydeffekter</Link></li>
			<li><Link href="#customcursor" alt="">Custom cursor</Link></li>
			<li><Link href="#videoonhover" alt="">:hover video</Link></li>
			<li><Link href="#foerstemotiononestump" alt="">Animation med Motion One</Link></li>	
			<li><Link href="#entranceanimation" alt="">Entrance animation</Link></li>
			<li><Link href="#inview" alt="">inView</Link></li>	
			<li><Link href="#stagger" alt="">Stagger</Link></li>
			<li><Link href="#timelineanimation" alt="">Timeline animation</Link></li>	
			<li><Link href="#inviewandreturn" alt="">inView & return animation</Link></li>		
			<li><Link href="#crossfade" alt="">Crossfade on scroll</Link></li>
			<li><Link href="#scrollogzoom" alt="">Scrollzoom</Link></li>
			<li><Link href="#parallaxmedtekstbox" alt="">Parallax med tekstboks</Link></li>
			<li><Link href="#parallaxgrafik" alt="">Parallaxgrafik</Link></li>
			<li><Link href="#stickysektioner" alt="">Sticky stuff</Link></li>
			<li><Link href="#horisontalscroll" alt="">Horisontal scroll</Link></li>
			<li><Link href="#mangesektioner" alt="">Sektion med mange elementer der animerer ind</Link></li>
			<li><Link href="#videoscrubber" alt="">Videoscrubber</Link></li>
			<li><Link href="#progressbar" alt="">Progress-bar</Link></li>
		</div>
	</ul>
	</section>

	<!-- Rolling/marquee banner -->
	<section id="rollingbanner" class="pt-1">
	<h2 class="text-6xl font-extrabold font-black">Rolling banner</h2>
	<p>Hvem er ikke vild med et rolling banner (aka marquee banner)? Måske nogen af jer tænker <span class="italic">hvad er det</span>? Se toppen af sitet, lige under hero unit'en. Der har jeg lavet et:-)</p>
	<p>Et rolling banner kan laves relativt nemt med lidt html, et par keyframe animationer og lidt css/tailwind. Først html'en: I dette eksempel er html'en placeret i Header.astro-filen, da den er en del af Hero unit'en. Men den kan placeres hvor du ønsker det:</p>
	<Code code={`
<section class="whitespace-nowrap overflow-x-hidden bg-pink-800 text-white py-4">
    <div class="inline-block animate-infinite-scroll whitespace-nowrap [&_span]:mx-6 ">
        <span>UI Lir</span>
        <span>Fede effekter</span>
        <span>Flotte animationer</span>
        <span>Høje lyde</span>
        <span>Livlige og levende webløsninger</span>
        <span>UI & UX</span>
        <span>Interaktioner</span>
        <span>Mikroanimationer</span>
        <span>Mega fedt!</span>
        <span>Dit site bliver bedre!</span>
    </div>
    <div class="inline-block animate-infinite-scroll whitespace-nowrap [&_span]:mx-6 " aria-hidden="true">
        <span>UI Lir</span>
        <span>Fede effekter</span>
        <span>Flotte animationer</span>
        <span>Høje lyde</span>
        <span>Livlige og levende webløsninger</span>
        <span>UI & UX</span>
        <span>Interaktioner</span>
        <span>Mikroanimationer</span>
        <span>Mega fedt!</span>
        <span>Dit site bliver bedre!</span>
    </div>
</section>
	`} lang="html">
	</Code>
	<p>For at få banneret til at scrolle i uendelighed, skal indholdet i banneret laves to gange, og derefter animeres: Derfor er der to  &lt;div&gt;'er, der er ens.</p>
	<ul>
		<li>De to  &lt;div&gt;'er er pakket ind i en ydre  &lt;section&gt;, der definerer bannerets udseende (farver mm.). Dertil har den egenskaben "whitespace-nowrap," som gør at de to &lt;div&gt;'er' placeres efter hinanden i stedet for oven på hinanden.</li>
		<li>Første  &lt;div&gt; er den, der er på skærmen til at starte med. Den scroller mod venstre ved hjælp af animate-infinite-scroll animationen.</li>
		<li>[&_span]:mx-6 er en lille genvej: Den tilføjer mx-6 class'en på alle de child &lt;span&gt; elementer, der er i &lt;div&gt;'en.</li>
		<li>Anden  &lt;div&gt; identisk med den første, men fordi den ligger efter den første pga. "whitespace-nowrap", er den til at starte med skubbet ud af skærmen. Den animererer (også) fra langt ude i højre side, og ind i skærmen, ved hjælp af animate-infinite-scroll animationen.</li>
		<li>aria-hidden="true" skjuler &lt;div&gt; nr. 2 for skærmlæsere/robotter</li>
	</ul>
	<p>Dernæst animate-infinite-scroll-animationen: Den tilføjes og tilpasses via tailwind.config.mjs-filen:</p>
	<Code code={`
	theme: {
		extend: {
            animation: {
                'infinite-scroll': 'infinite-scroll 25s linear infinite',
              },
              keyframes: {
                'infinite-scroll': {
                  from: { transform: 'translateX(0)' },
                  to: { transform: 'translateX(-100%)' },
                },
              }
        },
	},
	`} lang="js">
	</Code>
	<ul>
		<li><span class="italic">infinite-scroll</span> animerer indholdet, fra dets aktuelle startposition, og 100% mod venstre, ud af skærmen (-100%).</li>
	</ul>
	<p>OBS! Det er vigtigt at indholdet af de &lt;div&gt;'er er længere end containeren, de skal udfylde! </p>
	</section>

	<!-- Lydeffekter -->
	<section id="lydeffekter" class="pt-1" x-data>
	<h2 class="text-6xl font-extrabold font-black cursor cursor-handcursor" @mouseenter="$refs.wauwlyd.play()">Lydeffekter</h2>
	<audio x-ref="wauwlyd">
		<source src="wauw.mp3" type="audio/mpeg">
	</audio>
	<p>Det er ret nemt at lave lydeffekter på et website, specielt når alpine.js kan bruges til det.</p>
	<h3 class="">Find et par gode lydeffekter</h3>
	<p>Du kan finde lydeffekter flere steder, f.eks.:</p>
	<ul>
		<li><Link href="https://mixkit.co/free-sound-effects/" target="_blank">https://mixkit.co/free-sound-effects/</Link></li>
		<li><Link href="https://www.tunepocket.com/user-interface-ui-sounds/" target="_blank">https://www.tunepocket.com/user-interface-ui-sounds/</Link></li>
		<li><Link href="https://www.freesoundslibrary.com/game-and-interface-sounds/" target="_blank">https://www.freesoundslibrary.com/game-and-interface-sounds/</Link></li>
	</ul>
	<p>Filerne ligger i forskellige formater – sørg for at konvertere til mp3. Det kan du gøre ved hjælp af Adobe Media Encoder eller online på f.eks. <Link href="https://cloudconvert.com/" target="_blank">https://cloudconvert.com/</Link></p>
	<p>Upload din lydfil til public-mappen i dit Astro-site.</p>
	<h3 class="">Definer "scopet"</h3>
	<p>Tilføj en x-data attribut for at definere “scopet” for lyden - du kan typisk bruge en section eller en component til at definere scopet for lyden. I dette eksempel, har jeg sat scopet til at være denne section:</p>
	<Code code={`
	<section id="lydeffekter" class="" x-data>
	`} lang="html">
	</Code>
	<h3 class="">Tilføj html audio element</h3>
	<p>Tilføj et audio element til html’en <Link href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio" target="_blank">https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio</Link></p>
	<audio x-ref="trykforatafspillelyd">
		<source src="applaus.mp3" type="audio/mpeg">
	</audio>
	<Code code={`
	<audio x-ref="trykforatafspillelyd">
		<source src="applaus.mp3" type="audio/mpeg">
	</audio>
	`} lang="html">
	</Code>
	<ul>
		<li>x-ref er alpine.js, og fungerer som en reference til audio-elementet. Det svarer til noget lignende:<br>
			const trykpaafotoet = document.queryselector… i traditionel javascript.
		</li>
	</ul>
	<h3 class="">Afspil lyden</h3>
	<p>For at afspille lyden bruges igen en lille stump alpine. I eksemplet afspilles lyden, når der klikkes på et foto:</p>
	<Image src={radio} alt="" type="image/webp" loading="lazy" 
	class="cursor cursor-handcursor"
	@click="$refs.trykforatafspillelyd.play()"></Image>
	<p>Kodestumpen består af lidt html med en alpine @click attribut:</p>
	<Code code={`
	<Image src={radio} alt="" type="image/webp" loading="lazy" 
	class="cursor cursor-handcursor"
	@click="$refs.trykforatafspillelyd.play()"></Image>
	`} lang="html">
	</Code>
	<ul>
		<li>@click er en event listener, der lytter om hvorvidt der bliver klikket på img-elementet.</li>
		<li>$refs.trykforatafspillelyd er en reference tilbage lydfilen, der blev inkluderet i lydafspilleren tidligere.</li>
		<li>play() er en javascript-stump, der afspiller lyden.</li>
	</ul>
	<h3 class="">Tilføj flere lyde</h3>
	<p>Gennemløb ovenstående for hver lyd, du vil tilføje.</p>
	<p>Hvis du vil afspille en lyd ved hover i stedet for click, kan du bruge @mouseenter eller @mouseleave i stedet for @click. Besynderligt nok kræver @moseenter at nogen har klikket et vilkårligt sted på siden for at fungere...!?</p>
	</section>

	<!-- Custom cursor -->
	<section id="customcursor" class="pt-1">
	<h2 class="text-6xl font-extrabold font-black">Custom Cursor</h2>
	<p>Det er nemt og sjovt at tilføje sine egne cursors.</p>
	<h3 class="">Lav grafikken</h3>
	<p>Først og fremmest gælder det om at få fat på en (lille) grafik-fil (max. 256 x 256 pixels). Se sektionen "usage notes" på <Link href="https://developer.mozilla.org/en-US/docs/Web/CSS/cursor#usage_notes" target="_blank">https://developer.mozilla.org/en-US/docs/Web/CSS/cursor#usage_notes</Link> vedr. filstørrelser og typer.</p>
	<p>Så: lav/design en lille cursor-fil, og placer den i “public” mappen i dit Astro website.</p>
	<h3 class="">Implementer i Tailwind</h3>
	<p>Jvf. <Link href="https://tailwindcss.com/docs/cursor#using-custom-values" target="_blank">https://tailwindcss.com/docs/cursor#using-custom-values</Link> kan cursors tilpasses i tailwind.</p>
	<p>Det kan gøres i tailwind.config.js filen, hvor man kan "extende" tailwind med diverse nye regler – se mit eksemplet nedenfor, der tilføjer en ny cursor-class til Tailwind.</p>
	<Code code={`
	theme: {
		extend: {
            cursor: {
            'handcursor': 'url(cursor.svg) 25 25, pointer',
        	}
        },
	},
	`} lang="js">
	</Code>
	<p>Sørg for at følge samme syntaks, så der står "theme, extend, cursor..." og tuborg-klammer i samme rækkefølge. Det fortæller tailwind at du vil konfigurere din cursor, så du senere kan bruge den.</p>
	<p>Giv din cursor et navn (I eksemplet er cursoren navngivet 'handcursor').</p>
	<p>Lav den css der skal til: en url() med stien til dit cursor-billede og afslut med “, pointer” (det er et obligatorisk fallback). I mit eksempel står der også 25 25, som er et par værdier, der justerer placeringen af din cursor. Se <Link href="https://developer.mozilla.org/en-US/docs/Web/CSS/cursor#syntax" target="_blank">https://developer.mozilla.org/en-US/docs/Web/CSS/cursor#syntax</Link> for yderligere info.</p>
	<p>Brug din nye cursor ved at tilføje classerne "cursor cursor-handcursor" til de html-elementer, der skal have din custom cursor på hover, jvf. eksemplet nedenfor, der tilføjer cursoren til Link komponenten.</p>
	<Code code={`
	---
	// Henter parametrene fra Astro.props
	const { href="#", target="_self"} = Astro.props; 
	---
	<a href={href} class="underline cursor cursor-handcursor" target={target}><slot /></a>
	`} lang="astro">
	</Code>
	<h3 class="">Custom cursor på mange elementer</h3>
	<p>Hvis cursoren skal bruges på mange elementer, f.eks. alle links og knapper, er det nemmere at tilføje den nye cursor-class til tailwind.css filen.</p>
	<p>Det kan gøres jvf. eksemplet nedenfor.</p>
	<Code code={`
	@layer base{
		a, button{
			@apply cursor-handcursor;
		}
	}		
	`} lang="css">
	</Code>
	<p>@layer base betyder at vi “bygger videre” på Tailwind, og er en konvention for det med at arbejde med Tailwind.</p>
	<p>Dernæst defineres de elementer (a og button), som cursoren skal være aktiv ved – du kan tilføje alle de elementer du vil. @apply tilføjer Tailwind-classes til de valgte elementer, i dette tilfælde den nye custom cursor class.</p>
	</section>

	<!-- Afspil video på :hover -->
	<section id="videoonhover" class="pt-1" x-data="{ videopopup: false }">
		<h2 class="text-6xl font-extrabold font-black cursor cursor-handcursor">:hover video</h2>
		<p>Internettet elsker videoer. Også små effektvideoer og GIF'er. GIF'er skal dog (typisk) ikke være GIF'er - brug små videoer i stedet. Men alt i alt: Der skal nogen på dit website!</p>
		<p>Først og fremmest kan du lave små videoer, der afspiller når brugeren kører musen over dem (<span class="font-bold" @mouseenter="$refs.hovervideo.play()" @mouseleave="$refs.hovervideo.pause()">eller noget tekst?</span>), som i eksemplet nedenfor.</p>
		<video x-ref="hovervideo" @mouseenter="$refs.hovervideo.play()" @mouseleave="$refs.hovervideo.pause()">
			<source src="regnvejr.mp4" type="video/mp4">
			<source src="regnvejr.webm" type="video/webm">
		</video>
		<h3>Definer scopet</h3>
		<p>Det er ret nemt. Start med at tilføje en x-data attribut for at definere “scopet” for videoen - du kan typisk bruge en section eller en component til at definere scopet for videoen. I dette eksempel, har jeg sat scopet til at være denne section:</p>
		<Code code={`
	<section id="videoonhover" x-data>
		`} lang="html">
		</Code>
		<h3>Tilføj videoen og start/stop afspilning</h3>
		<p>Som det næste, skal der tilføjes en video. Videoen skal have lidt JS til at starte og stoppe afspilning, når musen køres over. Det klares med Alpine JS:</p>
		<Code code={`
	<video x-ref="hovervideo" @mouseenter="$refs.hovervideo.play()" @mouseleave="$refs.hovervideo.pause()">
	<source src="regnvejr.mp4" type="video/mp4">
	<source src="regnvejr.webm" type="video/webm">
	</video>
		`} lang="html">
		</Code>
		<ul>
			<li>x-ref er en reference til videoen, som bruges til lidt javascript - her er videoen døbt "hovervideo"</li>
			<li>@mouseenter="$refs.hovervideo.play()" er alpinejs, og tager referencen til videoen, og starter afspilning, når musen køres ind over videoen</li>
			<li>@mouseleave="$refs.hovervideo.pause()" er (også) alpinejs, og tager referencen til videoen, og pauser afspilning, når musen køres ud af videoen</li>
		</ul>
		<p>Hvis du hellere vil starte/stoppe afspilning ved at køre musen over noget andet (tekst?), kan html'en se ud som følgende:</p>
		<Code code={`
	<span class="font-bold" @mouseenter="$refs.hovervideo.play()" @mouseleave="$refs.hovervideo.pause()">eksempelvis tekst</span>
		`} lang="html">
		</Code>
		<p>Overvej hvordan det skal fungere/erstattes på mobil, for det der med :hover fungerer ikke super godt på mobil:-/</p>
		<h3 class="text-4xl font-bold">Video popup</h3>
		<p>Du kan også få videoen til at <span class="font-bold" @mouseover="videopopup = ! videopopup" @mouseleave="videopopup = ! videopopup">poppe op et andet sted</span>.</p>
		<p>For at gøre det, skal du definere en variabel i din x-data attribut:</p>
		<Code code={`
	<section id="videoonhover" class="" x-data="{ videopopup: false }">
		`} lang="html">
		</Code>
		<p>Dernæst kan du et element, tekst eksempelvis, der ændrer variablens værdi mellem true og false, når musen kører over det:</p>
		<Code code={`
	<span class="font-bold" @mouseover="videopopup = ! videopopup" @mouseleave="videopopup = ! videopopup">poppe op et andet sted</span>
		`} lang="html">
		</Code>
		<p>Som det sidste, skal der også laves et video-element, der bruger true/false variablen og alpinejs x-show attributten til at vise/skjule videoen, alt afhængig af true/false variablens værdi:</p>
		<Code code={`
	<div class="videopopup fixed top-16 right-16 p-8 border-black border-4 bg-pink-500 z-50 drop-shadow-xl" x-show="videopopup">
	<video x-ref="videopopup" autoplay class="m-0 p-0 border-2 border-black">
	<source src="regnvejr.mp4" type="video/mp4">
	<source src="regnvejr.webm" type="video/webm">			 
	</video>
	</div>
		`} lang="html">
		</Code>
		
		<div class="videopopup fixed top-16 right-16 p-8 border-black border-4 bg-pink-500 z-50 drop-shadow-xl" x-show="videopopup">
			<video x-ref="videopopup" autoplay class="m-0 p-0 border-2 border-black">
				<source src="regnvejr.mp4" type="video/mp4">
				<source src="regnvejr.webm" type="video/webm">			 
			</video>
		</div>
	</section>

	<!-- Første Motion One stump -->
	<section class="pt-1" id="foerstemotiononestump">
	<h2 class="text-6xl font-extrabold font-black">Animation med Motion One</h2>
	<p>For at bruge Motion One, skal du i bunden af din side/template/komponent importere Motion One biblioteket i et script tag:</p>
	<Code code={`
	<script>
	/* Import af Motion One biblioteket */
	import { animate, stagger, inView, scroll, timeline } from "motion";
	</script>
	`} lang="js"> 
	</Code>
	<p>Så er Motion One installeret og klar til at blive brugt:-)</p>
	<p>OBS! En del af animationerne kan komme til at gøre viewporten for bred, så der kommer horisontale scrollbars. Så det kan blive nødvendigt at sætte "overflow-hidden" på dele af sitet. Forsøg at være så restriktiv som muligt i brugen af overflow-hidden: Sørg for at gøre det på sektioner/komponenenter i stedet for hele sitet, da det i givet fald kan give problemer med sticky elementer:</p>
	<Code code={`
	<header class="bg-pink-200">
		<Header></Header>
	</header>
	
	<div class="overflow-hidden">
		<main class="container mx-auto p-8 max-w-4xl">
			<slot />
		</main>
	</div>

	<footer class="bg-gradient-to-r to-pink-500 from-yellow-300">
		<Footer></Footer>
	</footer>
	`} lang="astro"> 
	</Code>
	</section>

	<!-- Entrance animation -->
	<section class="pt-1" id="entranceanimation">
	<h2 class="text-6xl font-extrabold font-black">Entrance animation</h2>
	<p>Lad os starte med noget simpelt - at tilføje en entrance animation, der får hele websitet til at fade ind, når det loades - prøv at reloade siden for at se animationen.</p>
	<p>Sådan en animation kan tilføjes i dit script-tag med ganske få kodestumper, lige efter det import statementet, der blev tilføjet i afsnittet "I gang med Motion One":</p>
	<Code code={`
	animate( "body", { opacity: [ 0, 1] }, { duration: 1 })
	`} lang="js"> 
	</Code>
	<ul>
		<li>animate() bruger Motion Ones animate funktion</li>
		<li>"body" er selectoren - den siger at det er vores body, der skal animeres. Den fungerer på samme måde som en CSS-selector.</li>
		<li>I Første tuborg-klamme defineres keyframene i animationen: &#123; opacity: [ 0, 1]  &#125;</li>
		<li>I andet sæt tuborg-klammer defineres indstillingerne for keyframe-animationen: &#123; duration: 1 &#125;</li>
	</ul>
	</section>

	<!-- Mere animate -->
	<section class="pt-1" id="mereanimate">
	<h2 class="text-6xl font-extrabold font-black origin-top-left mereanimate">Mere animate()</h2>
	<p>Prøv at gøre animate() funktionen lidt mere kompleks, som eksempelvis i overskriften herover. Her er der flere parametre i keyframe animationen: Opacity, scale, rotate, x, y, delay, duration, direction mm.</p>
	<Code code={`
	/* Mere animate() */
	animate(".mereanimate", 
	{ opacity: [ 0.4, 1, 0, 0.8], scale: [0.95, 1, 0.7, 0.9], rotate: [0, 180, 270, 360], x: [0, 50, 0, -50 ], y:[0, 50, 0, -50 ]}, 
	{ delay: 2, duration: 4, direction: "alternate", repeat: Infinity }
	)
	`} lang="js"> 
	</Code>
	<ul>
		<li>Det første sæt tuborg-klammer med "opacity, scale, rotate, x og y" definerer de transforms, der udføres, og de 4 keyframes, der er i denne animation. Her kan du tilføje alle de CSS transforms, du vil.</li>
		<li>Det andet sæt tuborg-klammer med "delay, duration, direction mm.," definerer dine parametre for animationenm, altså det der svarer til CSS Animation egenskaben. </li>
		<li>Læg mærke til at jeg har tilføjet et "delay" (i sekunder) - prøv at reloade siden, hvis du ikke kan se det i første omgang. Delayet måles fra når siden er loadet. </li>
	</ul>
	<p>NB: Jeg har tilføjet en tailwind class til overskriften: origin-top-left. Det placerer orienteringspunktet for animationen øverst til venstre på elementet:</p>
	<Code code={`
	<h2 class="text-6xl font-extrabold font-black origin-top-left mereanimate ">Mere animate()</h2>
	`} lang="astro"> 
	</Code>
	</section>	

	<!-- inView -->
	<section class="pt-1" id="inview">
	<h2 class="text-6xl font-extrabold font-black">inView animation</h2>
	<p>Indtil videre er animationerne bare blevet eksekveret når sitet er loadet. Men rigtig ofte vil vi gerne eksekvere animationerne, når brugeren ser det pågældende element i viewporten. Det kan vi gøre ved hjælp af inview()-funktionen. Fotoet herunder skubbes ind fra siden, når brugeren scroller ned til det</p>
	<Image src={dobbeltexp} alt="" type="image/webp" loading="lazy" class="fotoinview"></Image>
	<p>inView()-funktionen ser således ud for dette eksempel:</p>
	<Code code={`
	/* inView animation */
	inView( ".fotoinview" , () =>{
	animate( ".fotoinview", { x: [-2000, 0 ] }, { duration: 3 })
	})
	`} lang="js"> 
	</Code>
	<ul>
		<li>inView-funktionen tager først et element - i mit tilfælde et Image component med class'en "fotoinview"</li>
		<li>Dernæst ser paranteserne og pilen lidt kryptiske ud - de definerer en callback funktion - det der skal ske når elementetet er "inview."</li>
		<li>Callback funktionen består af en animate()-funktion, helt som anvendt i de sidste par eksempler. Den animerer blot på x-positionen i stedet for opacity og scale.</li>
	</ul>
	<p>I de følgende eksempler bruges inView til at "omkranse" mange af animationerne. Animationerne behøver ikke nødvendigvis først at starte "inView," men vil i mange tilfælde være det. Derfor er "inView" inkluderet i eksemplerne.</p>
	</section>

	<!-- Stagger animation -->
	<section class="pt-1" id="stagger">
	<h2 class="text-6xl font-extrabold font-black">Stagger animation</h2>
	<p>Stagger funktionen giver en række elementer den samme animation, men med et delay mellem hvert element. Se f.eks. listen nedenfor (reload evt. for at se animationen):</p>
	<ul class="staggeranimation text-2xl">
		<li>Stagger</li>
		<li>Stagger senere</li>
		<li>Stagger endnu senere</li>
		<li>Stagger meget senere</li>
		<li>Stagger sidst</li>
	</ul>	
	<p>Stagger animationer kan laves med følgende kodestump:</p>
	<Code code={`
	/* Stagger animation */
	inView( "#stagger" , () =>{
		animate(
		".staggeranimation li",
		{ opacity: [0, 1] },
		{ 
			delay: stagger(1, { start: 2 })
		}
		)
	})
	`} lang="js"> 
	</Code>
	<ul>
		<li>Først vælges alle de elementer, der skal "staggeres" - jeg har valgt alle list items nede i en ul med class'en staggeranimation. Men du kan lave selectoren som du ønsker.</li>
		<li>Dernæst definerer jeg keyframe-indstillingerne for stagger animationen</li>
		<li>Til sidst anvender jeg keyframe animationen med et delay, som tilføjer "stagger" på alle elementer. </li>
		<li>I kodestumpen stagger(1, &#123; start: 2 &#125; refererer 1-tallet til et delay i antal sekunder mellem hvert list item.</li>
		<li>start: 2 refererer til hvor lang tid der skal gå, før det første list item animeres ind.</li>
	</ul>
	<p>I ovenstående eksempel har jeg brugt en unordered list og stagget alle list items. Men du kan sagtens bruge den på andre elementer - f.eks. billeder i en section, som nedenfor. Og du kan også lave din keyframe animation vildere:-) Og du behøver ikke nødvendigvis at pakke stagger animationen ind i inView-funktionen.</p>
	<div class="fotosektioninview grid grid-cols-3 gap-2">
		<Image src={radio} alt="" type="image/webp"></Image>
		<Image src={radio} alt="" type="image/webp"></Image>
		<Image src={radio} alt="" type="image/webp"></Image>
	</div>
	</section>

	<!-- Timeline animation -->
	<section class="pt-1" id="timelineanimation">
	<h2 class="text-6xl font-extrabold font-black">Timeline animation</h2>
	<p>Med en timeline kan flere animationer bindes sammen (chaines), så de eksekveres én efter én. Se animationerne på billedet nedenfor (reload eventuelt for at se animationen):</p>
	<Image src={dobbeltexp} alt="" type="image/webp" loading="lazy" class="opacity-0 timelineanimation" id="timelineanimationimage"></Image>
	<p>Timeline animationen er lavet med følgende kodestump:</p>
	<Code code={`
	/* Timeline animation */
	inView( "#timelineanimationimage" , () =>{
	const timelineanimation = [
	[".timelineanimation", { opacity: 1 }, { duration: 5 }],
	[".timelineanimation", { transform: "rotate(360deg)" }, { duration: 3 }],
	[".timelineanimation", { transform: "scale(1.5)" }, { duration: 0.5 }],
	[".timelineanimation", { transform: "scale(1)" }, { duration: 1 }],
	[".timelineanimation", { opacity: 0.3 }, { duration: 5 }],
	]
	timeline( timelineanimation );
	})
	`} lang="js"> 
	</Code>
	<ul>
		<li>Først oprettes  et array til timelineanimationen, så animation kan deles op i små bidder/sekvenser.</li>
		<li>Hver sekvens i animationen puttes i et sæt firkantede parenteser, og keyframe animationen for hver sekvens defineres.</li>
	</ul>
	<p>OBS! Den første animation tager 5 sekunder, og ændrer "opacity" til 1. Opacity på 1 er også default-værdien, så for at gøre elementet usynligt til at starte med, skal html-element have tailwind-class'en opacity-0:</p>
	<Code code={`
	<Image src={dobbeltexp} alt="" type="image/webp" loading="lazy" class="opacity-0 timelineanimation" id="timelineanimationimage"></Image>
	`} lang="astro"> 
	</Code>
	</section>

	<!-- InView & Return animation -->
	<section class="pt-1" id="inviewandreturn">
	<h2 class="text-6xl font-extrabold font-black">inView & Return animation</h2>
	<p>Indtil videre er animationerne blevet eksekveret én gang. Hvis du gerne vil have dem til at starte (forfra) hver gang elementet vises i viewporten, kan du bruge inView()s return funktion. Se eksempelvis billedet herunder. Det er roteret 180 grader, når det kommer ind i viewporten, og bliver så roteret tilbage til 0 grader med animate()-funktionen. Scroller du væk, vender det tilbage til 180 grader, og næste gang det kommer ind i viewporten igen, roterer det til 0 grader igen."</p>
	<Image src={dobbeltexp} alt="" type="image/webp" loading="lazy" class="inviewreturn"></Image>
	<p>Return funktionen fyres af efter den første animate()-funktionen, jvf. nedenstående eksempel:</p>
	<Code code={`
	/* inView & return */
	inView( ".inviewreturn", ({ target }) => {
  	animate(
      target,
      { rotate: 0 },
      { delay: 1, duration: 2 },
  	) 
    return () => {
      animate(
        target,
        { rotate: 180 }
      )
  	}
	}) 
	`} lang="js"> 
	</Code>
	<p>Læg også mærke til: (&#123;  target &#125; ). Target betyder at callback funktionen får sendt det valgte element med - altså selectoren ".inviewreturn"</p>
	<p>Det kan så bruges animate-funktionens selector til at sige "vælg den værdi der er i target" - altså .inviewreturn</p>
	</section>

	<!-- Crossfade -->
	<section class="pt-1 overflow-hidden" id="crossfade">
	<h2 class="text-6xl font-extrabold font-black">Crossfade on scroll</h2>
	<p>Lad os se på hvordan man kan crossfade mellem to billeder baseret på hvor langt brugeren er scrollet i en container, som i eksemplet nedenfor:</p>
	<section class="crossfadeimages mx-auto relative h-screen lg:w-screen">
		<Image src={kodakelektralitefarver} alt="" class="crossfadetopimg object-cover h-screen absolute top-0 z-0 my-0" />
		<Image src={kodakelektralitesh} alt="" class="crossfadebottomimg object-cover h-screen absolute top-0 z-0 my-0" />	
	</section>
	<p>(Astro) HTML'en:</p>
	<Code code={`
	<section class="crossfadeimages mx-auto relative h-screen lg:w-screen">
		<img src="kodakelektralitefarver.webp" alt="" class="crossfadetopimg object-cover h-screen absolute top-0 z-0 my-0">
		<img src="kodakelektralitesh.webp" alt="" class="crossfadebottomimg object-cover h-screen absolute top-0 z-0 my-0">
	</section>
	`} lang="astro">
	</Code>
	<p>HTML'en består af to billeder, der ligger præcis samme sted ved hjælp af absolute/relative positionering.  Parent elementet er positioneret "relative," så child elementerne (billeder) positioneres absolut i forhold til det relative element.</p>
	<p>I eksemplet bruges et img elementet med billeder i public-mappen, men du kan med fordel bruge Astros Image component i stedet - Image componenten driller når man skal lave kode-dokumentation, derfor har jeg brugt et img-element.</p>
	<p>Script-stumpen:</p>
	<Code code={`
	/* Crossfade to billeder */
	scroll(
	animate(".crossfadebottomimg", {
		opacity: [1, 0]
	}), {
		target: document.querySelector(".crossfadeimages"),
		offset: ["-25vh", "25vh"]
	}
	);
	`} lang="js">
	</Code>
	<p>Script stumpen bruger Motion One scroll-funktionen til at checke hvor langt ned i elementet med "crossfadeimages" classen (den relative container), brugeren er scrollet. Animate-funktionen bruges til at ændre opacity fra 1 til 0 på det nederste billede. Offset bruges til at styre hvornår crossfadet skal starte/være færdiggjort. I dette tilfælde starter opacity-animationen 25vh FØR det relative element kommer ind på skærmen.</p>
	</section>

	<!-- Scrollzoom -->
	<p></p>
		<section class="pt-1" id="scrollogzoom">
		<h2 class="text-6xl font-extrabold font-black">Scrollzoom (eller scroll og Zoom)</h2>
		<p>I eksemplet nedenfor, scrolles først ned i et billede, og efter at billedet er scrollet et stykke ned, bliver der zoomet i det.</p>
		<section class="scrollzoom overflow-clip">
		<Image src={doubleshot} class="scrollzoomimg w-full" alt="">
		</section> 
		<p>Det kan gøres ret let med en scrool og animate funktion. Først html'en:</p>
		<Code code={`
	<section class="scrollzoom overflow-clip">
	<Image src={doubleshot} class="scrollzoomimg w-full" alt="">
	</section> 
		`} lang="html">
		</Code>
		<p>Dernæst er der javascript-stumpen, som benytter scroll-funktionen:</p>
	<Code code={`
	scroll(
    animate(".scrollzoomimg", { 
        scale: [1, 1.5]    
    }),
    { 
      target: document.querySelector(".scrollzoom"),
      offset: ["0.75 end", "end end"]
    }
    )
	`} lang="js">
	</Code>
	<ul>
		<li>"target" refererer til det element, der lyttes efter om der scrolles i - dvs. min section med class'en scrollzoom. Og den er lige så høj som billedet.</li>
		<li>Offset referer til hvornår animate-funktionen skal startes og være færdiggjort, f.eks. ["0.75 end", "end end"]. 
			<ul>
				<li>"0.75 end" betyder at animationen skal startes når "0.75 (dvs. 75%) af billedet rammer "end" af containeren (dvs. bundend af skærmen)". Du kan putte de talværdier ind du vil: Første tal referer til hvor langt nede i billedet, andet tal referer til hvor langt nede i containeren kontaktpunktet skal være (0 er toppen, 1 bunden)</li>
				<li>"end end" betyder at animationen skal være færdig når "end af target/billedet rammer end af containeren (bunden af skærmen). Igen: Første tal referer til hvor langt nede i billedet, andet tal referer til hvor langt nede i containeren kontaktpunktet skal være (0 er toppen, 1 bunden)</li>
			</ul> 
		</li>
	<p>Det kan fungerer fint at lave scrollzoom i fuld skærmbredde:</p>
	</ul>
		<section class="scrollzoomfullwidth overflow-clip fullwidthsection">
		<Image src={doubleshot} class="scrollzoomimgfullwidth w-full" alt="">
		</section> 
	</section>
	

	<!-- Parallax med tekstboks -->
	<section class="pt-1" id="parallaxmedtekstbox">
	<h2 class="text-6xl font-extrabold font-black">Parallax med tekstboks</h2>
	<p>Parallax-sektioner ses ofte anvendt på webdoks. Parallax-sektioner kan laves med Motion Ones scroll-funktion. Scroll-funktionen lytter på hvor langt man er scrollet ned i et givent element, og så kan man animere et andet element oven på dette for at lave parallax-effekten. Se sektionen nedenfor, hvor teksten bevæger sig hurtigere end baggrunden. </p>
	<section class="parallaxcontainer bg-teal-100 mt-8 h-screen w-100 bg-cover bg-center" style="background-image: url('/hurtig.jpg');">
	<p  class="parallaxelement w-3/4 mx-auto p-10 bg-slate-50 text-xl">Cupcake lollipop caramels toffee pastry. Bear claw dessert cotton candy ice cream cotton candy lemon drops jelly biscuit. Topping marzipan tart bonbon powder.</p>
	</section>
	<p>HTML'en består af en section med et baggrundsbillede og en paragraph med tekst. Begge stylet med Tailwind:</p>
	<Code code={`
	<section class="bg-teal-100 mt-8 h-screen w-100 bg-cover bg-center" style="background-image: url('/hurtig.jpg');">
	<p class="parallaxelement w-3/4 mx-auto p-10 bg-slate-50 text-xl">Cupcake lollipop caramels toffee pastry. Bear claw dessert cotton candy ice cream cotton candy lemon drops jelly biscuit. Topping marzipan tart bonbon powder.</p>
	</section>
	`} lang="html">
	</Code>
	<ul>
		<li>OBS! Baggrundsbilledet på section-elementet er lagt i public-mappen, så det er nemt at tilføje med style-tagget.</li>
		<li>Tekst-afsnittet har class'en parallaxelement, som bruges til at parallaxe med JS/Motion.</li>
	</ul>
	<p>Så er der javascript-stumpen, der kan laves kort og præcist med Motion Ones scroll-funktion:</p>
	<Code code={`
	/* Parallax med tekstboks */ 
	scroll(animate(".parallaxelement", { y: [50, 500] }), {
		target: document.querySelector(".parallaxelement"),
	});
	`} lang="js">
	</Code>
	<ul>
		<li>scroll() bruges til at lytte om der scrolles i "noget", og hvis ja: Udfører animate()-funktionen, som laver en forskydelse af y-aksen jvf. værdierne 50 og 500</li>
		<li>target: siger hvilket element, der skal lyttes efter, om der bliver scrollet i - i dette tilfælde det samme som det vi animerer med scroll-funktionen.</li>
	</ul>
	</section>

	<!-- Parallaxgrafik -->
	<section class="pt-1" id="parallaxgrafik">
	<h2 class="text-6xl font-extrabold font-black">Parallaxgrafik</h2>
	<p class="">Parallax-sektioner kan også nemt bruges til at lave en fin, lille grafisk kollage: 
	<section class="parallaxgrafik fullwidthsection">	
		<div class="bg-teal-100 mt-8 h-screen w-full bg-cover bg-center grid grid-cols-12 overflow-hidden" style="background-image: url('/havet.jpg');">
			<Image src={baad1} alt="" class="col-start-2 parallaxgrafik1"></Image>
			<Image src={baad2} alt="" class="col-start-5 parallaxgrafik2"></Image>
			<Image src={baad3} alt="" class="col-start-3 col-span-2 parallaxgrafik3"></Image>
		</div>
	</section>
	<p>HTML'en består af en section med class'en parallaxgrafik, som bruges til JS/Motion One stumpten. Dertil er der en &lt;div&gt; med et baggrundsbillede (inline styles) og et 12-kolonnet grid, som bruges til at placere de grafiske elementer (de små både). Alt er stylet med Tailwind, bort set fra baggrundsbilledet:</p>
	<Code code={`
	<section class="parallaxgrafik fullwidthsection">	
		<div class="bg-teal-100 mt-8 h-screen w-full bg-cover bg-center grid grid-cols-12 overflow-hidden" style="background-image: url('/havet.jpg');">
			<Image src={baad1} alt="" class="col-start-2 parallaxgrafik1"></Image>
			<Image src={baad2} alt="" class="col-start-5 parallaxgrafik2"></Image>
			<Image src={baad3} alt="" class="col-start-3 col-span-2 parallaxgrafik3"></Image>
		</div>
	</section>
	`} lang="html">
	</Code>
	<ul>
		<li>OBS! Baggrundsbilledet på &lt;div&gt;'en er lagt i public-mappen, så det er nemt at tilføje med style-tagget.</li>
		<li>Billederne af bådene er placeret i grid'et ved hjælp af forskellige Tailwind col-start classes.</li>
		<li>Billederne af bådene har hver deres class (parallaxgrafik1, 2 og 3), som bruges til at parallaxe med JS/Motion One.</li>
	</ul>
	<p>Så er der javascript-stumpen, der animerer grafik-elementerne med Motion Ones scroll-funktion:</p>
	<Code code={`
	/* Parallaxgrafik */ 
	scroll(animate(".parallaxgrafik1", { y: [400, -600] }), {
		target: document.querySelector(".parallaxgrafik"), offset: ["start end", "end start"]
	});
	scroll(animate(".parallaxgrafik2", { x:[-100, 100], y: [800, -1800] }), {
		target: document.querySelector(".parallaxgrafik"), offset: ["start end", "end start"]
	});
	scroll(animate(".parallaxgrafik3", { x: [-1500, 2000], y: [400, 0] }), {
		target: document.querySelector(".parallaxgrafik"), offset: ["start end", "end start"]
	});
	`} lang="js">
	</Code>
	<p>scroll()-funktionen bruges tre gange til at animere de forskellige grafik-elementer. Funktionen er stort set ens i alle tre tilfælde:</p>
	<ul>
		<li>scroll() bruges til at lytte om der scrolles i "noget", og hvis ja: Udfører animate()-funktionen</li>
		<li>animate()-funktionen tager grafikelementet (parallaxgrafik1, parallaxgrafik2 og parallaxgrafik3) og forskyder det i x- og y- retningen.</li>
		<li>target: siger hvilket element, der skal lyttes efter, om der bliver scrollet i - i dette tilfælde &lt;section&gt;'en, der omkranser alt parallax-indholdet, og har class'en parallaxgrafik</li>
		<li>offset: er en beskrivelse af hvornår animationen skal starte og slutte. "start end" betyder at animationen skal starte "når starten af target elementet rammer bunden/slutnignen af containeren (skærmen)" og "end start" betyder at animationen skal væres slut, når bunden/slutningen af target elementet rammer toppen/starten af containeren (skærmen).</li>
	</ul>
	</section>

	<!-- Sticky -->
	<section class="pt-1" id="stickysektioner">
	<h2 class="text-6xl font-extrabold font-black">Sticky</h2>
	<p>"Sticky" sektioner ses også ofte anvendt i webfeatures - indimellem kombineret med parallax. Målet er at give brugerne lidt ro til at læse tekstbidderne. Sticky-sektioner kan laves nemt bare med Tailwind. Se de tre sektioner nedenfor, som "sticyk'er" teksten fast i toppen af skærmen. </p>
	<article class="fullwidthsection">
		<div class="flex items-center h-screen w-100 bg-cover bg-center" style="background-image: url('/astro.jpg')" >
			<p class="w-3/4 lg:w-1/2 mx-auto p-10 bg-slate-50 text-xl sticky top-1/4">Well, the way they make shows is, they make one show. That show's called a pilot.</p>
		</div>
		<div class="flex items-center h-screen w-100 bg-cover bg-center" style="background-image: url('/forsker.jpg')" >
			<p class="w-3/4 lg:w-1/2 mx-auto p-10 bg-slate-50 text-xl sticky top-1/4">Then they show that show to the people who make shows, and on the strength of that one show they decide if they're going to make more shows.</p>
		</div>
		<div class="flex items-center h-screen w-100 bg-cover bg-center" style="background-image: url('/penge.jpg')" >
			<p class="w-3/4 lg:w-1/2 mx-auto p-10 bg-slate-50 text-xl sticky top-1/4">Some pilots get picked and become television programs. Some don't, become nothing.</p>
		</div>	
	</article>
	<p>For at lave sticky-sektioner gælder det egentlig bare om at tilføje tailwinds sticky class, og så definere hvor den skal være sticky - her top-0:</p>
	<Code code={`
	<div class="flex items-center h-screen w-100 bg-cover bg-center" style="background-image: url('/astro.jpg')" >
		<p class="w-3/4 lg:w-1/2 mx-auto p-10 bg-slate-50 text-xl sticky top-1/4">Well, the way they make shows is, they make one show. That show's called a pilot.</p>
	</div>
	`} lang="html">
	</Code>
	<p>En anden måde at bruge "sticky" sektioner på er at sticky'e hele sektioner, eventuelt med en lille parallaxe-effekt på: </p>
	<article class="fullwidthsection">
		<div class="flex items-center h-screen w-100 bg-cover bg-center sticky top-0" style="background-image: url('/astro.jpg')" >
			<p class="w-3/4 lg:w-1/4 ml-2 lg:ml-64 p-10 bg-slate-50 text-xl stickyparallax1">Well, the way they make shows is, they make one show. That show's called a pilot.</p>
		</div>
		<div class="flex items-center h-screen w-100 bg-cover bg-center sticky top-0" style="background-image: url('/forsker.jpg')" >
			<p class="w-3/4 lg:w-1/4 ml-2 lg:ml-64 p-10 bg-slate-50 text-xl stickyparallax2">Then they show that show to the people who make shows, and on the strength of that one show they decide if they're going to make more shows.</p>
		</div>
		<div class="flex items-center h-screen w-100 bg-cover bg-center sticky top-0" style="background-image: url('/penge.jpg')" >
			<p class="w-3/4 lg:w-1/4 ml-2 lg:ml-64 p-10 bg-slate-50 text-xl stickyparallax3">Some pilots get picked and become television programs. Some don't, become nothing.</p>
		</div>	
	</article>
	<p>Her er sticky class'en placeret på elementerne med billedbaggrunde på:</p>
	<Code code={`
		<div class="flex items-center h-screen w-100 bg-cover bg-center sticky top-0" style="background-image: url('/astro.jpg')" >
			<p class="w-3/4 lg:w-1/4 lg:ml-64 p-10 bg-slate-50 text-xl stickyparallax1">Well, the way they make shows is, they make one show. That show's called a pilot.</p>
		</div>
	`} lang="html">
	</Code>
	<p>Parallax'en er lavet med en JS/Motion One kodestump efter samme fremgangsmåde som <Link href="#parallaxmedtekstbox">Parallax med tekstboks"</Link> dokumentationen:</p>
	<Code code={`
	scroll(animate(".stickyparallax1", { y: [-300, 0] }), {
		target: document.querySelector(".stickyparallax1"),
	});
	`} lang="js">
	</Code>
	</section>

	<!-- Horisontalt scrollende sektion -->
	<section class="pt-1" id="horisontalscroll">
	<h2 class="text-6xl font-extrabold font-black">Horisontal scroll</h2>
	<p>For at bryde det vertikale flow (den uendelige scrollen nedad), kan det være sjovt at tilføje en horisontalt scrollende sektion, som reagerer på et op/nedadgående scroll. Se f.eks. <Link href="https://bananablossomsalads.com/" alt="" target="_blank">Banana Blossom Salads</Link>, der bruger det rigtig fint til at fremvise en menu. Eller eksemplet nedenfor:</p>
	<div class="overflow-clip">
		<section id="horisontalscrollsection" class="h-[500vh]">
			<ul id="horisontalliste" class="list-none pl-0 flex sticky top-[10vh]">
			<li class="pl-0 flex w-[100vw] items-start justify-center flex-col overflow-hidden flex-grow-0 flex-shrink-0 flex-auto"><figure class="flex flex-row max-w-[800px]"><Image src={lomo} class="w-2/3" alt="foto" /><figcaption class="pl-4 italic w-1/3">Dette fine, lille kamera er et Diana F, der skyder med 120-film.</figcaption></figure></li>
			<li class="flex w-[100vw] items-start justify-center flex-col overflow-hidden flex-grow-0 flex-shrink-0 flex-auto"><figure class="flex flex-row max-w-[800px]"><Image src={lomo} class="w-2/3" alt="foto" /><figcaption class="pl-4 italic w-1/3">Dette fine, lille kamera er et Diana F, der skyder med 120-film.</figcaption></figure></li>
			<li class="flex w-[100vw] items-start justify-center flex-col overflow-hidden flex-grow-0 flex-shrink-0 flex-auto"><figure class="flex flex-row max-w-[800px]"><Image src={lomo} class="w-2/3" alt="foto" /><figcaption class="pl-4 italic w-1/3">Dette fine, lille kamera er et Diana F, der skyder med 120-film.</figcaption></figure></li>
			<li class="flex w-[100vw] items-start justify-center flex-col overflow-hidden flex-grow-0 flex-shrink-0 flex-auto"><figure class="flex flex-row max-w-[800px]"><Image src={lomo} class="w-2/3" alt="foto" /><figcaption class="pl-4 italic w-1/3">Dette fine, lille kamera er et Diana F, der skyder med 120-film.</figcaption></figure></li>
			<li class="flex w-[100vw] items-start justify-center flex-col overflow-hidden flex-grow-0 flex-shrink-0 flex-auto"><figure class="flex flex-row max-w-[800px]"><Image src={lomo} class="w-2/3" alt="foto" /><figcaption class="pl-4 italic w-1/3">Dette fine, lille kamera er et Diana F, der skyder med 120-film.</figcaption></figure></li>
			</ul>
		</section>
	</div>
	<h3>Teknikken bag horisontal scroll</h3>
	<p>I eksemplet her er der en række forskellige ting, der skal arbejde sammen. Først og fremmest i html'en:</p>
	<ul>
		<li>Den horisontale sektion er lidt tricky. Først er der en section, inde i den section er der en unordered list, og listen består så - i dette tilfælde - af 5 list items.</li>
		<li>Der kommer højre-scrollbars på sitet, fordi den horisontale sektion fylder for meget. Så jeg har pakket den horisontale sektion ind i en &lt;div&gt; med class'en overflow-clip:</li>		
	</ul>
	<Code code={`
	<div class="overflow-clip">
		<section id="horisontalscrollsection" class="h-[500vw]">
			<ul id="horisontalliste" class="list-none pl-0 flex sticky top-[10vh]">
			<li class="pl-0 flex w-[100vw] items-start justify-center flex-col overflow-hidden flex-grow-0 flex-shrink-0 flex-auto"><figure class="flex flex-row max-w-[800px]"><Image src={lomo} class="w-2/3" alt="foto" /><figcaption class="pl-4 italic w-1/3">Dette fine, lille kamera er et Diana F, der skyder med 120-film.</figcaption></figure></li>
			<li class="flex w-[100vw] items-start justify-center flex-col overflow-hidden flex-grow-0 flex-shrink-0 flex-auto"><figure class="flex flex-row max-w-[800px]"><Image src={lomo} class="w-2/3" alt="foto" /><figcaption class="pl-4 italic w-1/3">Dette fine, lille kamera er et Diana F, der skyder med 120-film.</figcaption></figure></li>
			<li class="flex w-[100vw] items-start justify-center flex-col overflow-hidden flex-grow-0 flex-shrink-0 flex-auto"><figure class="flex flex-row max-w-[800px]"><Image src={lomo} class="w-2/3" alt="foto" /><figcaption class="pl-4 italic w-1/3">Dette fine, lille kamera er et Diana F, der skyder med 120-film.</figcaption></figure></li>
			<li class="flex w-[100vw] items-start justify-center flex-col overflow-hidden flex-grow-0 flex-shrink-0 flex-auto"><figure class="flex flex-row max-w-[800px]"><Image src={lomo} class="w-2/3" alt="foto" /><figcaption class="pl-4 italic w-1/3">Dette fine, lille kamera er et Diana F, der skyder med 120-film.</figcaption></figure></li>
			<li class="flex w-[100vw] items-start justify-center flex-col overflow-hidden flex-grow-0 flex-shrink-0 flex-auto"><figure class="flex flex-row max-w-[800px]"><Image src={lomo} class="w-2/3" alt="foto" /><figcaption class="pl-4 italic w-1/3">Dette fine, lille kamera er et Diana F, der skyder med 120-film.</figcaption></figure></li>
			</ul>
		</section>
	</div>
	`} lang="html">
	</Code>	
	<p>Et par vigtige ting ved html'en er:</p>
	<ul>
		<li>Min section er sat til at have en højde på 500 vw med tailwinds class til at tilføje custom højder: h-[500vw]. Så matcher højden af elementet med bredden af scroll-sektionen. Højden på elementet afgør scroll-hastigheden, da det er det "target," der lyttes efter hvor langt man er scrollet i. Jeg har valgt at have 5 elementer i min horisontale sektion, og bruger derfor en størrelse på h-[500vw] - havde jeg f.eks. 3 eller 7 elementer i min horisontale sektion, ville jeg gå efter en størrelse på hhv. h-[300vw] h-[700vw] for at få en passende scroll-hastighed. Kort sagt: Højden skal matche den horisontale sektions bredde. </li>
		<li>Min ul'er er sat til sticky top-[10vh] - det kan tilpasses efter behov</li>
		<li>Hver enkelt li-element er sat til en bredde på 100vvw ved hjælp af w-[100vw]. Deruodver er der en række flex-classes til justering af indholdet. Hvis du vil have sektionerne til at fylde mindre, kan du sætte en anden/fast bredde - så skal du bare opdatere højden, jvf. punktet ovenfor, og en lille stump JS (kommer senere).</li>
	</ul>
	<p>Og så er der javascript bidden:</p>
	<Code code={`
	/* Horisontal scroll sektion */
	scroll(
	animate("#horisontalliste", {
		transform: ["none", "translateX(-500vw)"]
	}),
	{ target: document.querySelector("#horisontalscrollsection") }
	); 
	`} lang="js">
	</Code>	
	<ul>
		<li>Transform med translateX er her sat til -500vw fordi der er 5 indholdselementer i listen. Har du f.eks. syv, sætter du den til -700vw, har du 3, sætter du den til -300vw mm. </li>
		<li>Skal du have to eller flere horisontale scroll-sektioner, kan du bare kopiere kodestumpen, og ændre id'er på de efterfølgende horisontal scroll sektioner samt i JS-stumperne.</li>
	</ul>
	</section>

	<!-- Sektion med mange elementer, der animerer ind i viewporten -->
	<section class="pt-1" id="mangesektioner">
	<h2 class="text-6xl font-extrabold font-black">Sektion med mange elementer der animerer ind</h2>
	<p class="">Hvordan man kan animere mange ting ind i skærmen på én gang, lidt ligesom på <Link href="https://www.dr.dk/nyheder/webfeature/facebookgrupper" target="_blank">DR's webfeature om Facebook</Link>?</p>
	<article class="">
		<div class="sticky top-1/4 mangeelementerinview grid grid-cols-5">
		  <div class="p-8 bg-green-700 text-center text-white mangeelementer1">1</div>
		  <div class="p-8 bg-blue-500 text-center text-white mangeelementer2">2</div>
		  <div class="p-8 bg-orange-400 text-center text-white mangeelementer3">3</div>
		  <div class="p-8 bg-black text-center text-white mangeelementer4">4</div>
		  <div class="p-8 bg-purple-600 text-center text-white mangeelementer5">5</div>
		  <div class="p-8 bg-lime-600 text-center text-white mangeelementer6">6</div>
		  <div class="p-8 bg-slate-400 text-center text-white mangeelementer7">7</div>
		  <div class="p-8 bg-orange-600 text-center text-white mangeelementer8">8</div>
		  <div class="p-8 bg-red-400 text-center text-white mangeelementer9">9</div>
		  <div class="p-8 bg-pink-500 text-center text-white mangeelementer10">10</div>
		</div>
		<div class="h-screen">
		</div>
	  </article>  
	<h3 class="">Teknikken bag</h3>
	<p class="">I html'en: Først har jeg lavet en container/article det hele. Dernæst to &lt;div&gt;'er: Den første &lt;div&gt; består af et grid på 5 kolonner. Inde i det grid er der en masse &lt;div&gt;'er, med hver sin class (mangeelementer1...10). &lt;div&gt;en er position: sticky. &lt;div&gt; nr. 2 fungerer bare som fyldstof:</p>
	<Code code={`
	<article class="">
	<div class="sticky top-1/4 mangeelementerinview grid grid-cols-5">
		  <div class="p-8 bg-green-700 text-center text-white mangeelementer1">1</div>
		  <div class="p-8 bg-blue-500 text-center text-white mangeelementer2">2</div>
		  <div class="p-8 bg-orange-400 text-center text-white mangeelementer3">3</div>
		  <div class="p-8 bg-black text-center text-white mangeelementer4">4</div>
		  <div class="p-8 bg-purple-600 text-center text-white mangeelementer5">5</div>
		  <div class="p-8 bg-lime-600 text-center text-white mangeelementer6">6</div>
		  <div class="p-8 bg-slate-400 text-center text-white mangeelementer7">7</div>
		  <div class="p-8 bg-orange-600 text-center text-white mangeelementer8">8</div>
		  <div class="p-8 bg-red-400 text-center text-white mangeelementer9">9</div>
		  <div class="p-8 bg-pink-500 text-center text-white mangeelementer10">10</div>
	</div>
	<div class="h-screen">
	</div>
	</article>  
	`} lang="html">
	</Code>
	<p>Dernæst skal der lidt javascript til. Her har jeg brugt inView funktionen til at checke at elementet er i viewporten. Dernæst bliver hver enkelt element animeret med animate()-funktionen. Jeg animerer hver enkelt element, så de kan forskydes uafhængigt af hinanden. Efter animate-funktionerne er der en retur/callback-funktion, som egentlig bare gentager animationerne. Så vil animationen virke hver gang elementet kommer ind i viewporten.: </p>
	<Code code={`
/* Mange elementer der animerer ind */
	inView( ".mangeelementerinview", () =>{
	animate( ".mangeelementer1", { x: [-2000, 0 ], y: [-50, 0 ] }, { duration: 1 }) 
	animate( ".mangeelementer2", { x: [-1500, 0 ], y: [-100, 0 ] }, { duration: 3 })
	animate( ".mangeelementer3", { x: [-1000, 0 ], y: [-150, 0 ] }, { duration: 3 })
	animate( ".mangeelementer4", { x: [1750, 0 ] }, { duration: 2 })
	animate( ".mangeelementer5", { x: [-2000, 0 ], y: [-100, 0 ]  }, { duration: 1 })
	animate( ".mangeelementer6", { x: [2000, 0 ] }, { duration: 2 })
	animate( ".mangeelementer7", { x: [1500, 0 ], y: [50, 0 ] }, { duration: 3 })
	animate( ".mangeelementer8", { x: [1000, 0 ], y: [150, 0 ] }, { duration: 2 })
	animate( ".mangeelementer9", { x: [1500, 0 ], y: [0, 0 ] }, { duration: 1 })
	animate( ".mangeelementer10", { x: [2000, 0 ] , y: [50, 0 ] }, { duration: 2 })
	return () => {
		animate( ".mangeelementer1", { x: [-2000, 0 ], y: [-50, 0 ] }, { duration: 1 }) 
		animate( ".mangeelementer2", { x: [-1500, 0 ], y: [-100, 0 ] }, { duration: 3 })
		animate( ".mangeelementer3", { x: [-1000, 0 ], y: [-150, 0 ] }, { duration: 3 })
		animate( ".mangeelementer4", { x: [1750, 0 ] }, { duration: 2 })
		animate( ".mangeelementer5", { x: [-2000, 0 ], y: [-100, 0 ]  }, { duration: 1 })
		animate( ".mangeelementer6", { x: [2000, 0 ] }, { duration: 2 })
		animate( ".mangeelementer7", { x: [1500, 0 ], y: [50, 0 ] }, { duration: 3 })
		animate( ".mangeelementer8", { x: [1000, 0 ], y: [150, 0 ] }, { duration: 2 })
		animate( ".mangeelementer9", { x: [1500, 0 ], y: [0, 0 ] }, { duration: 1 })
		animate( ".mangeelementer10", { x: [2000, 0 ] , y: [50, 0 ] }, { duration: 2 })
   		}
  	})
	`} lang="js">
	</Code>
	</section>

	<!-- Video scrubber -->
	<section class="sticky pt-1" id="videoscrubber">
	<h2 class="text-6xl font-extrabold font-black">Video scrubber</h2>
	<p>Video scrubbing går ud på at afspille en video alt efter hvor meget man er scrollet ned i et container-element. Det kombineres typisk med "position sticky." Videoen skal helst være meget kompakt, ellers bliver det noget tungt for browseren at arbejde med. Og scroll-scrubbingen bliver heller ikke helt smooth i Firefox. Se eksemplet nedenfor:</p>
	<div class="">
		<div class="videocontainer sticky top-[20%] w-full h-full">
			<video  muted loop playsinline class="w-full" id="videofil" >
				<source src="/lumix1025.mp4" type="video/mp4">
				<source src="/lumix1025.webm" type="video/webm">
			</video>
		</div>
		<div class="h-screen videoscroller"></div>
	</div>
	<h3>Scroll-scrubbing - teknikken bag</h3>
	<p>I html'en: Først og fremmest er der en "videocontainer", som er "sticky." Videocontaineren indeholder en videofil (html5 video). Efter video-div'en, er der en tom div, der fylder én skærmhøjde (h-screen). Den bruges til at justere scroll-længden for scroll-scrubberen. Det giver følgende html:</p>
	<Code code={`
	<div class="videocontainer sticky top-[20%] w-full h-full">
	<video  muted loop playsinline class="w-full" id="videofil" >
		<source src="/lumix1025.mp4" type="video/mp4">
		<source src="/lumix1025.webm" type="video/webm">
	</video>
	</div>
	<div class="h-screen videoscroller"></div>
	`} lang="html">
	</Code>
	<p>Dernæst er der lidt js til at håndtere scroll-scrubbingen:</p>
	<Code code={`
	/* Scroll scrubber */
	const scrubbervideo = document.querySelector("#videofil");
	scrubbervideo.pause();	
	scroll(
		({ y }) => {
		if (!scrubbervideo.readyState) return;
		scrubbervideo.currentTime = scrubbervideo.duration * y.progress;
		},
		{
		target: document.querySelector(".videoscroller"),
		offset: ["start end", "end start"]
		}
	);
	`} lang="js">
	</Code>
	<ul>
		<li>Først oprettes en const med en reference til videofilen</li>
		<li>Dernæst sættes afspilningen af videoen på pause (i html'en er den sat til at autplaye)</li>
		<li>Motion Ones scroll(funktion) anvendes til: 
			<ul>
				<li>At checke hvor langt der er scrollet i target, og kører videoen frem/tilbage til en tilsvarende position i videoen.</li>
				<li>target: siger hvilket element, der skal lyttes efter, om der bliver scrollet i</li>
				<li>offset: er en beskrivelse af hvornår videoscrubberen skal starte og slutte. "start end" betyder at scrubberen skal starte "når starten af target elementet rammer bunden/slutnignen af containeren (skærmen)" og "end start" betyder at animationen skal væres slut, når bunden/slutningen af target elementet rammer toppen/starten af containeren (skærmen).</li>
			</ul>
		</li>
	</ul>
	</section>

	<!-- Progress bar -->
	<section id="progressbar" class="pt-1">
	<h2 class="text-6xl font-extrabold font-black">Progress-bar</h2>
	<p>Læg mærke til toppen af sitet - der er en progress-bar/læseindikator, der viser hvor langt nede på siden brugeren er. Du kan lave en progress-bar ved hjælp af to stumper: En html-og-tailwind stump, der styrer udseendet, og en JS/Motion One stump, der styrer hvor meget af progress-baren, der vises.</p>
	<p>Først og fremmest er progress-baren "designet" med Tailwind. Jeg har placeret den nederst i html'en, da den alligevel bare bliver positioneret "fixed" over alt andet indhold:</p>
	<Code code={`
	<!-- Progress-bar placeret i toppen af sitet -->
	<div class="progress-bar h-4 fixed w-full bg-gradient-to-r from-pink-500 to-yellow-300 left-0 origin-top-left top-0 right-0"></div>
	`} lang="html">
	</Code>
	<p>Dernæst er der en JS/Motion One stump, der bruger Motion Ones scroll-funktion: </p>
	<Code code={`
	/*Progress-baren/læseindikatoren */
	scroll( animate(".progress-bar", { scaleX: [0, 1] }));
	`} lang="js">
	</Code>
	<p>Her udfører scroll-funktionen en animate-funktion, der skalerer progress-baren op i størrelse fra 0 til 1 (fuld størrelse), alt afhængig af hvor langt brugeren er scrollet ned på siden.</p>
	<p>En progress-bar behøver ikke at være fastgjort til toppen - den kan f.eks. også være i venstre eller højre side af skærmen - så skal html'en og JS/Motion One stumpen tilpasses lidt:</p>
	<Code code={`
	<!-- Progress-bar placeret i venstre side af sitet -->
	<div class="progress-bar h-4 fixed h-full bg-gradient-to-b from-pink-500 to-yellow-300 left-0 origin-top-left top-0 right-[99%]"></div>
	`} lang="html">
	</Code>
	<p>Og JS'en:</p> 
	<Code code={`
	/*Progress-baren/læseindikatoren */
	scroll( animate(".progress-bar", { scaleY: [0, 1] }));
	`} lang="js">
	</Code>
	</section>

	<!-- Progress-baren på det her site -->
	<div class="progress-bar h-4 fixed w-full bg-gradient-to-r from-pink-500 to-yellow-300 left-0 origin-top-left top-0 right-0"></div>
</MainLayout>

<script>
	/* Import af Motion One bibliotek */
	import { animate, stagger, inView, scroll, ScrollOffset, timeline } from "motion";

	/* Entrance animation */
	animate( "body", { opacity: [ 0, 1] }, { duration: 1 });

	/* inView animation */
	inView( ".fotoinview" , () =>{
	animate( ".fotoinview", { x: [-2000, 0 ] }, { duration: 3 })
	})

	/* Mere animate() */
	animate(".mereanimate", 
	{ opacity: [ 0.4, 1, 0, 0.8], scale: [0.95, 1, 0.7, 0.9], rotate: [0, 180, 270, 360], x: [0, 50, 0, -50 ], y:[0, 50, 0, -50 ]}, 
	{ delay: 2, duration: 4, direction: "alternate", repeat: Infinity }
	)

	/* Stagger animation */
	inView( "#stagger" , () =>{
		animate(
		".staggeranimation li",
		{ opacity: [0, 1] },
		{ 
			delay: stagger(1, { start: 2 })
		}
		)
	})

	/* Stagger på fotosektion  */
	inView( ".fotosektioninview" , ({ target }) =>{
	animate( target.querySelectorAll("img") , 
		{ opacity: [0, 1] }, 
		{ duration: 2, delay: stagger(1, { start: 2 }) }
		)
	})

	/* Timeline animation */
	inView( "#timelineanimationimage" , () =>{
		const timelineanimation = [
		[".timelineanimation", { opacity: 1 }, { duration: 5 }],
		[".timelineanimation", { transform: "rotate(360deg)" }, { duration: 3 }],
		[".timelineanimation", { transform: "scale(1.5)" }, { duration: 0.5 }],
		[".timelineanimation", { transform: "scale(1)" }, { duration: 1 }],
		[".timelineanimation", { opacity: 0.3 }, { duration: 5 }],
		]
		timeline( timelineanimation );
	})

	/* inView & return */
	inView( ".inviewreturn", ({ target }) => {
  	animate(
      target,
      { rotate: 0 },
      { delay: 1, duration: 2 },
  	) 
    return () => {
      animate(
        target,
        { rotate: 180 }
      )
  	}
	})  

	/* Crossfade to billeder */
	scroll(
		animate(".crossfadebottomimg", {
			opacity: [1, 0]
		}), {
			target: document.querySelector(".crossfadeimages"),
			offset: ["-25vh", "25vh"]
		}
	);

	/*Scrollzoom*/
	scroll(
        animate(".scrollzoomimg", { 
          scale: [1, 1.5]    
        }),
        { 
          target: document.querySelector(".scrollzoom"),
          offset: ["0.75 end", "end end"]
       }
      )
	scroll(
        animate(".scrollzoomimgfullwidth", { 
          scale: [1, 1.5]    
        }),
        { 
          target: document.querySelector(".scrollzoomfullwidth"),
          offset: ["0.70 end", "0.9 end"]
       }
    )

	/* Parallax med tekstboks */ 
	scroll(animate(".parallaxelement", { y: [50, 500] }), {
		target: document.querySelector(".parallaxelement"),
	});

	/* Parallaxgrafik */ 
	scroll(animate(".parallaxgrafik1", { y: [400, -600] }), {
		target: document.querySelector(".parallaxgrafik"), offset: ["start end", "end start"]
	});
	scroll(animate(".parallaxgrafik2", { x:[-100, 100], y: [800, -1800] }), {
		target: document.querySelector(".parallaxgrafik"), offset: ["start end", "end start"]
	});
	scroll(animate(".parallaxgrafik3", { x: [-1500, 2000], y: [400, 0] }), {
		target: document.querySelector(".parallaxgrafik"), offset: ["start end", "end start"]
	});

	/* sticky parallax */
	scroll(animate(".stickyparallax1", { y: [-300, 0] }), {
		target: document.querySelector(".stickyparallax1"),
	});
	scroll(animate(".stickyparallax2", { y: [-300, 0] }), {
		target: document.querySelector(".stickyparallax2"),
	});
	scroll(animate(".stickyparallax3", { y: [-300, 0] }), {
		target: document.querySelector(".stickyparallax3"),
	});

	/* Horisontal scroll sektion */
	const items = document.querySelectorAll("#horisontalliste li");
	scroll(
	animate("#horisontalliste", {
		transform: ["none", `translateX(-${items.length - 1}00vw)`]
	}),
	{ target: document.querySelector("#horisontalscrollsection") }
	); 

	/* Mange elementer der animerer ind */
	inView( ".mangeelementerinview", () =>{
		animate( ".mangeelementer1", { x: [-2000, 0 ], y: [-50, 0 ] }, { duration: 1 }) 
		animate( ".mangeelementer2", { x: [-1500, 0 ], y: [-100, 0 ] }, { duration: 3 })
		animate( ".mangeelementer3", { x: [-1000, 0 ], y: [-150, 0 ] }, { duration: 3 })
		animate( ".mangeelementer4", { x: [1750, 0 ] }, { duration: 2 })
		animate( ".mangeelementer5", { x: [-2000, 0 ], y: [-100, 0 ]  }, { duration: 1 })
		animate( ".mangeelementer6", { x: [2000, 0 ] }, { duration: 2 })
		animate( ".mangeelementer7", { x: [1500, 0 ], y: [50, 0 ] }, { duration: 3 })
		animate( ".mangeelementer8", { x: [1000, 0 ], y: [150, 0 ] }, { duration: 2 })
		animate( ".mangeelementer9", { x: [1500, 0 ], y: [0, 0 ] }, { duration: 1 })
		animate( ".mangeelementer10", { x: [2000, 0 ] , y: [50, 0 ] }, { duration: 2 })
		return () => {
		animate( ".mangeelementer1", { x: [-2000, 0 ], y: [-50, 0 ] }, { duration: 1 }) 
		animate( ".mangeelementer2", { x: [-1500, 0 ], y: [-100, 0 ] }, { duration: 3 })
		animate( ".mangeelementer3", { x: [-1000, 0 ], y: [-150, 0 ] }, { duration: 3 })
		animate( ".mangeelementer4", { x: [1750, 0 ] }, { duration: 2 })
		animate( ".mangeelementer5", { x: [-2000, 0 ], y: [-100, 0 ]  }, { duration: 1 })
		animate( ".mangeelementer6", { x: [2000, 0 ] }, { duration: 2 })
		animate( ".mangeelementer7", { x: [1500, 0 ], y: [50, 0 ] }, { duration: 3 })
		animate( ".mangeelementer8", { x: [1000, 0 ], y: [150, 0 ] }, { duration: 2 })
		animate( ".mangeelementer9", { x: [1500, 0 ], y: [0, 0 ] }, { duration: 1 })
		animate( ".mangeelementer10", { x: [2000, 0 ] , y: [50, 0 ] }, { duration: 2 })
    	}
  	})

	/* Scroll scrubber */
	const scrubbervideo = document.querySelector("#videofil");
	scrubbervideo.pause();	
	scroll(
		({ y }) => {
		if (!scrubbervideo.readyState) return;
		scrubbervideo.currentTime = scrubbervideo.duration * y.progress;
		},
		{
		target: document.querySelector(".videoscroller"),
		offset: ["start end", "end start"]
		}
	);

	/* Progress-baren/læseindikatoren */
	scroll( animate(".progress-bar", { scaleX: [0, 1] }));
</script>